// Code generated by protoc-gen-go. DO NOT EDIT.
// source: approve/approve.proto

package approve

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/yuansuan/ticp/PSP/psp/internal/common/proto/ptype"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/emptypb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type OperateTypeEnum int32

const (
	OperateTypeEnum_UNKNOWN           OperateTypeEnum = 0
	OperateTypeEnum_FILE_MANAGER      OperateTypeEnum = 1
	OperateTypeEnum_USER_MANAGER      OperateTypeEnum = 2
	OperateTypeEnum_RBAC_MANAGER      OperateTypeEnum = 3
	OperateTypeEnum_JOB_MANAGER       OperateTypeEnum = 4
	OperateTypeEnum_APP_MANAGER       OperateTypeEnum = 5
	OperateTypeEnum_NODE_MANAGER      OperateTypeEnum = 6
	OperateTypeEnum_LICENSE_MANAGER   OperateTypeEnum = 7
	OperateTypeEnum_PROJECT_MANAGER   OperateTypeEnum = 8
	OperateTypeEnum_VIS_MANAGER       OperateTypeEnum = 9
	OperateTypeEnum_SECURITY_APPROVAL OperateTypeEnum = 10
)

var OperateTypeEnum_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "FILE_MANAGER",
	2:  "USER_MANAGER",
	3:  "RBAC_MANAGER",
	4:  "JOB_MANAGER",
	5:  "APP_MANAGER",
	6:  "NODE_MANAGER",
	7:  "LICENSE_MANAGER",
	8:  "PROJECT_MANAGER",
	9:  "VIS_MANAGER",
	10: "SECURITY_APPROVAL",
}

var OperateTypeEnum_value = map[string]int32{
	"UNKNOWN":           0,
	"FILE_MANAGER":      1,
	"USER_MANAGER":      2,
	"RBAC_MANAGER":      3,
	"JOB_MANAGER":       4,
	"APP_MANAGER":       5,
	"NODE_MANAGER":      6,
	"LICENSE_MANAGER":   7,
	"PROJECT_MANAGER":   8,
	"VIS_MANAGER":       9,
	"SECURITY_APPROVAL": 10,
}

func (x OperateTypeEnum) String() string {
	return proto.EnumName(OperateTypeEnum_name, int32(x))
}

func (OperateTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_221462dfdcdf6f86, []int{0}
}

type CheckUnhandledApproveRequest struct {
	UserId               string   `protobuf:"bytes,1,opt,name=userId,proto3" json:"userId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" yaml:"-" xml:"-"`
	XXX_unrecognized     []byte   `json:"-" yaml:"-" xml:"-"`
	XXX_sizecache        int32    `json:"-" yaml:"-" xml:"-"`
}

func (m *CheckUnhandledApproveRequest) Reset()         { *m = CheckUnhandledApproveRequest{} }
func (m *CheckUnhandledApproveRequest) String() string { return proto.CompactTextString(m) }
func (*CheckUnhandledApproveRequest) ProtoMessage()    {}
func (*CheckUnhandledApproveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_221462dfdcdf6f86, []int{0}
}

func (m *CheckUnhandledApproveRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CheckUnhandledApproveRequest.Unmarshal(m, b)
}
func (m *CheckUnhandledApproveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CheckUnhandledApproveRequest.Marshal(b, m, deterministic)
}
func (m *CheckUnhandledApproveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckUnhandledApproveRequest.Merge(m, src)
}
func (m *CheckUnhandledApproveRequest) XXX_Size() int {
	return xxx_messageInfo_CheckUnhandledApproveRequest.Size(m)
}
func (m *CheckUnhandledApproveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckUnhandledApproveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckUnhandledApproveRequest proto.InternalMessageInfo

func (m *CheckUnhandledApproveRequest) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

type CheckUnhandledApproveResponse struct {
	Unhandled            bool     `protobuf:"varint,1,opt,name=unhandled,proto3" json:"unhandled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" yaml:"-" xml:"-"`
	XXX_unrecognized     []byte   `json:"-" yaml:"-" xml:"-"`
	XXX_sizecache        int32    `json:"-" yaml:"-" xml:"-"`
}

func (m *CheckUnhandledApproveResponse) Reset()         { *m = CheckUnhandledApproveResponse{} }
func (m *CheckUnhandledApproveResponse) String() string { return proto.CompactTextString(m) }
func (*CheckUnhandledApproveResponse) ProtoMessage()    {}
func (*CheckUnhandledApproveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_221462dfdcdf6f86, []int{1}
}

func (m *CheckUnhandledApproveResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CheckUnhandledApproveResponse.Unmarshal(m, b)
}
func (m *CheckUnhandledApproveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CheckUnhandledApproveResponse.Marshal(b, m, deterministic)
}
func (m *CheckUnhandledApproveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckUnhandledApproveResponse.Merge(m, src)
}
func (m *CheckUnhandledApproveResponse) XXX_Size() int {
	return xxx_messageInfo_CheckUnhandledApproveResponse.Size(m)
}
func (m *CheckUnhandledApproveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckUnhandledApproveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckUnhandledApproveResponse proto.InternalMessageInfo

func (m *CheckUnhandledApproveResponse) GetUnhandled() bool {
	if m != nil {
		return m.Unhandled
	}
	return false
}

// SaveAuditLogRequest SaveAuditLogRequest
type SaveAuditLogRequest struct {
	UserId               string          `protobuf:"bytes,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Username             string          `protobuf:"bytes,2,opt,name=Username,proto3" json:"Username,omitempty"`
	IpAddress            string          `protobuf:"bytes,3,opt,name=IpAddress,proto3" json:"IpAddress,omitempty"`
	OperateType          OperateTypeEnum `protobuf:"varint,4,opt,name=OperateType,proto3,enum=approve.OperateTypeEnum" json:"OperateType,omitempty"`
	OperateContent       string          `protobuf:"bytes,5,opt,name=OperateContent,proto3" json:"OperateContent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-" yaml:"-" xml:"-"`
	XXX_unrecognized     []byte          `json:"-" yaml:"-" xml:"-"`
	XXX_sizecache        int32           `json:"-" yaml:"-" xml:"-"`
}

func (m *SaveAuditLogRequest) Reset()         { *m = SaveAuditLogRequest{} }
func (m *SaveAuditLogRequest) String() string { return proto.CompactTextString(m) }
func (*SaveAuditLogRequest) ProtoMessage()    {}
func (*SaveAuditLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_221462dfdcdf6f86, []int{2}
}

func (m *SaveAuditLogRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SaveAuditLogRequest.Unmarshal(m, b)
}
func (m *SaveAuditLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SaveAuditLogRequest.Marshal(b, m, deterministic)
}
func (m *SaveAuditLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SaveAuditLogRequest.Merge(m, src)
}
func (m *SaveAuditLogRequest) XXX_Size() int {
	return xxx_messageInfo_SaveAuditLogRequest.Size(m)
}
func (m *SaveAuditLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SaveAuditLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SaveAuditLogRequest proto.InternalMessageInfo

func (m *SaveAuditLogRequest) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *SaveAuditLogRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *SaveAuditLogRequest) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *SaveAuditLogRequest) GetOperateType() OperateTypeEnum {
	if m != nil {
		return m.OperateType
	}
	return OperateTypeEnum_UNKNOWN
}

func (m *SaveAuditLogRequest) GetOperateContent() string {
	if m != nil {
		return m.OperateContent
	}
	return ""
}

// AuditLogEmptyReply AuditLogEmptyReply
type AuditLogEmptyReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-" yaml:"-" xml:"-"`
	XXX_unrecognized     []byte   `json:"-" yaml:"-" xml:"-"`
	XXX_sizecache        int32    `json:"-" yaml:"-" xml:"-"`
}

func (m *AuditLogEmptyReply) Reset()         { *m = AuditLogEmptyReply{} }
func (m *AuditLogEmptyReply) String() string { return proto.CompactTextString(m) }
func (*AuditLogEmptyReply) ProtoMessage()    {}
func (*AuditLogEmptyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_221462dfdcdf6f86, []int{3}
}

func (m *AuditLogEmptyReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuditLogEmptyReply.Unmarshal(m, b)
}
func (m *AuditLogEmptyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuditLogEmptyReply.Marshal(b, m, deterministic)
}
func (m *AuditLogEmptyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditLogEmptyReply.Merge(m, src)
}
func (m *AuditLogEmptyReply) XXX_Size() int {
	return xxx_messageInfo_AuditLogEmptyReply.Size(m)
}
func (m *AuditLogEmptyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditLogEmptyReply.DiscardUnknown(m)
}

var xxx_messageInfo_AuditLogEmptyReply proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("approve.OperateTypeEnum", OperateTypeEnum_name, OperateTypeEnum_value)
	proto.RegisterType((*CheckUnhandledApproveRequest)(nil), "approve.CheckUnhandledApproveRequest")
	proto.RegisterType((*CheckUnhandledApproveResponse)(nil), "approve.CheckUnhandledApproveResponse")
	proto.RegisterType((*SaveAuditLogRequest)(nil), "approve.SaveAuditLogRequest")
	proto.RegisterType((*AuditLogEmptyReply)(nil), "approve.AuditLogEmptyReply")
}

func init() { proto.RegisterFile("approve/approve.proto", fileDescriptor_221462dfdcdf6f86) }

var fileDescriptor_221462dfdcdf6f86 = []byte{
	// 510 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0x5b, 0x6f, 0xd3, 0x30,
	0x14, 0xc7, 0x9b, 0x5d, 0x7a, 0x71, 0xd1, 0x9a, 0x79, 0x14, 0x45, 0x59, 0x11, 0x53, 0x24, 0xa6,
	0x09, 0x89, 0x46, 0x2a, 0x12, 0x0f, 0x48, 0x3c, 0xa4, 0x21, 0xa0, 0x8c, 0x2e, 0xa9, 0xdc, 0x76,
	0x08, 0x5e, 0x26, 0xaf, 0x39, 0x6b, 0x2b, 0x1a, 0xdb, 0x34, 0xce, 0xa4, 0x3e, 0xf0, 0x09, 0xf9,
	0x06, 0x7c, 0x1a, 0x94, 0x4b, 0xd3, 0x50, 0x06, 0x3c, 0x25, 0xff, 0xdf, 0xff, 0x5c, 0xe4, 0xe3,
	0x63, 0xd4, 0xa6, 0x42, 0xac, 0xf8, 0x3d, 0x98, 0xf9, 0xb7, 0x2b, 0x56, 0x5c, 0x72, 0x5c, 0xcb,
	0xa5, 0xfe, 0x6c, 0xc6, 0xf9, 0x6c, 0x09, 0x66, 0x8a, 0x6f, 0xe3, 0x3b, 0x53, 0x2e, 0x42, 0x88,
	0x24, 0x0d, 0x45, 0x16, 0xa9, 0xab, 0x42, 0xae, 0x05, 0x98, 0x82, 0xce, 0xf2, 0x5c, 0xfd, 0x74,
	0x37, 0x05, 0x42, 0x21, 0xd7, 0x99, 0x69, 0xbc, 0x46, 0x1d, 0x7b, 0x0e, 0xd3, 0xaf, 0x13, 0x36,
	0xa7, 0x2c, 0x58, 0x42, 0x60, 0x65, 0x8d, 0x08, 0x7c, 0x8b, 0x21, 0x92, 0xf8, 0x09, 0xaa, 0xc6,
	0x11, 0xac, 0xdc, 0x40, 0x53, 0xce, 0x94, 0x8b, 0x06, 0xc9, 0x95, 0xf1, 0x16, 0x3d, 0xfd, 0x4b,
	0x5e, 0x24, 0x38, 0x8b, 0x00, 0x77, 0x50, 0x23, 0xde, 0x78, 0x69, 0x6e, 0x9d, 0x6c, 0x81, 0xf1,
	0x43, 0x41, 0x27, 0x23, 0x7a, 0x0f, 0x56, 0x1c, 0x2c, 0xe4, 0x80, 0xcf, 0x4a, 0xed, 0x26, 0xbf,
	0xb5, 0xcb, 0x14, 0xd6, 0x51, 0x3d, 0xf9, 0x63, 0x34, 0x04, 0x6d, 0x2f, 0x75, 0x0a, 0x9d, 0x74,
	0x72, 0x85, 0x15, 0x04, 0x2b, 0x88, 0x22, 0x6d, 0x3f, 0x35, 0xb7, 0x00, 0xbf, 0x41, 0x4d, 0x5f,
	0xc0, 0x8a, 0x4a, 0x18, 0xaf, 0x05, 0x68, 0x07, 0x67, 0xca, 0xc5, 0x51, 0x4f, 0xeb, 0x6e, 0xc6,
	0x5b, 0xf2, 0x1c, 0x16, 0x87, 0xa4, 0x1c, 0x8c, 0xcf, 0xd1, 0x51, 0x2e, 0x6d, 0xce, 0x24, 0x30,
	0xa9, 0x1d, 0xa6, 0xe5, 0x77, 0xa8, 0xf1, 0x18, 0xe1, 0xcd, 0x41, 0x9c, 0x64, 0xb6, 0x04, 0xc4,
	0x72, 0xfd, 0xe2, 0xa7, 0x82, 0x5a, 0x3b, 0xe5, 0x71, 0x13, 0xd5, 0x26, 0xde, 0x47, 0xcf, 0xff,
	0xe4, 0xa9, 0x15, 0xac, 0xa2, 0x47, 0xef, 0xdd, 0x81, 0x73, 0x73, 0x65, 0x79, 0xd6, 0x07, 0x87,
	0xa8, 0x4a, 0x42, 0x26, 0x23, 0x87, 0x14, 0x64, 0x2f, 0x21, 0xa4, 0x6f, 0xd9, 0x05, 0xd9, 0xc7,
	0x2d, 0xd4, 0xbc, 0xf4, 0xfb, 0x05, 0x38, 0x48, 0x80, 0x35, 0x1c, 0x16, 0xe0, 0x30, 0xc9, 0xf1,
	0xfc, 0x77, 0xdb, 0xba, 0x55, 0x7c, 0x82, 0x5a, 0x03, 0xd7, 0x76, 0xbc, 0xd1, 0x16, 0xd6, 0x12,
	0x38, 0x24, 0xfe, 0xa5, 0x63, 0x8f, 0x0b, 0x58, 0x4f, 0x8a, 0x5d, 0xbb, 0xa3, 0x02, 0x34, 0x70,
	0x1b, 0x1d, 0x8f, 0x1c, 0x7b, 0x42, 0xdc, 0xf1, 0xe7, 0x1b, 0x6b, 0x38, 0x24, 0xfe, 0xb5, 0x35,
	0x50, 0x51, 0x0f, 0xb6, 0x47, 0xbe, 0xa2, 0x8c, 0xce, 0x20, 0x04, 0x26, 0xb1, 0x8f, 0xd4, 0xf2,
	0xad, 0xba, 0xec, 0x8e, 0xe3, 0x4e, 0x31, 0xeb, 0x07, 0x2e, 0x5c, 0x3f, 0x2d, 0xdc, 0x3f, 0x27,
	0x68, 0x54, 0x7a, 0xdf, 0xd1, 0x71, 0xbe, 0x58, 0xa5, 0x2e, 0x73, 0xd4, 0x7e, 0x70, 0xf7, 0xf0,
	0xf3, 0xa2, 0xd8, 0xbf, 0x76, 0x5a, 0x3f, 0xff, 0x5f, 0x58, 0xb6, 0xc2, 0x46, 0xa5, 0x6f, 0x7e,
	0x79, 0xb9, 0x8e, 0x29, 0x8b, 0x62, 0xca, 0xba, 0x53, 0x66, 0x8a, 0x48, 0x98, 0x0b, 0x26, 0x93,
	0xbd, 0x5b, 0x9a, 0x53, 0x1e, 0x86, 0x9c, 0x65, 0xaf, 0x6a, 0xf3, 0x5a, 0x6f, 0xab, 0xa9, 0x7c,
	0xf5, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x00, 0xc0, 0xd9, 0x80, 0xc7, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuditLogManagementClient is the client API for AuditLogManagement service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuditLogManagementClient interface {
	// Save audit log info
	SaveAuditLogInfo(ctx context.Context, in *SaveAuditLogRequest, opts ...grpc.CallOption) (*AuditLogEmptyReply, error)
}

type auditLogManagementClient struct {
	cc *grpc.ClientConn
}

func NewAuditLogManagementClient(cc *grpc.ClientConn) AuditLogManagementClient {
	return &auditLogManagementClient{cc}
}

func (c *auditLogManagementClient) SaveAuditLogInfo(ctx context.Context, in *SaveAuditLogRequest, opts ...grpc.CallOption) (*AuditLogEmptyReply, error) {
	out := new(AuditLogEmptyReply)
	err := c.cc.Invoke(ctx, "/approve.AuditLogManagement/SaveAuditLogInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuditLogManagementServer is the server API for AuditLogManagement service.
type AuditLogManagementServer interface {
	// Save audit log info
	SaveAuditLogInfo(context.Context, *SaveAuditLogRequest) (*AuditLogEmptyReply, error)
}

// UnimplementedAuditLogManagementServer can be embedded to have forward compatible implementations.
type UnimplementedAuditLogManagementServer struct {
}

func (*UnimplementedAuditLogManagementServer) SaveAuditLogInfo(ctx context.Context, req *SaveAuditLogRequest) (*AuditLogEmptyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveAuditLogInfo not implemented")
}

func RegisterAuditLogManagementServer(s *grpc.Server, srv AuditLogManagementServer) {
	s.RegisterService(&_AuditLogManagement_serviceDesc, srv)
}

func _AuditLogManagement_SaveAuditLogInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveAuditLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditLogManagementServer).SaveAuditLogInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/approve.AuditLogManagement/SaveAuditLogInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditLogManagementServer).SaveAuditLogInfo(ctx, req.(*SaveAuditLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuditLogManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "approve.AuditLogManagement",
	HandlerType: (*AuditLogManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SaveAuditLogInfo",
			Handler:    _AuditLogManagement_SaveAuditLogInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "approve/approve.proto",
}

// ApproveManagementClient is the client API for ApproveManagement service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApproveManagementClient interface {
	CheckUnhandledApprove(ctx context.Context, in *CheckUnhandledApproveRequest, opts ...grpc.CallOption) (*CheckUnhandledApproveResponse, error)
}

type approveManagementClient struct {
	cc *grpc.ClientConn
}

func NewApproveManagementClient(cc *grpc.ClientConn) ApproveManagementClient {
	return &approveManagementClient{cc}
}

func (c *approveManagementClient) CheckUnhandledApprove(ctx context.Context, in *CheckUnhandledApproveRequest, opts ...grpc.CallOption) (*CheckUnhandledApproveResponse, error) {
	out := new(CheckUnhandledApproveResponse)
	err := c.cc.Invoke(ctx, "/approve.ApproveManagement/CheckUnhandledApprove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApproveManagementServer is the server API for ApproveManagement service.
type ApproveManagementServer interface {
	CheckUnhandledApprove(context.Context, *CheckUnhandledApproveRequest) (*CheckUnhandledApproveResponse, error)
}

// UnimplementedApproveManagementServer can be embedded to have forward compatible implementations.
type UnimplementedApproveManagementServer struct {
}

func (*UnimplementedApproveManagementServer) CheckUnhandledApprove(ctx context.Context, req *CheckUnhandledApproveRequest) (*CheckUnhandledApproveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUnhandledApprove not implemented")
}

func RegisterApproveManagementServer(s *grpc.Server, srv ApproveManagementServer) {
	s.RegisterService(&_ApproveManagement_serviceDesc, srv)
}

func _ApproveManagement_CheckUnhandledApprove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUnhandledApproveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApproveManagementServer).CheckUnhandledApprove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/approve.ApproveManagement/CheckUnhandledApprove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApproveManagementServer).CheckUnhandledApprove(ctx, req.(*CheckUnhandledApproveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApproveManagement_serviceDesc = grpc.ServiceDesc{
	ServiceName: "approve.ApproveManagement",
	HandlerType: (*ApproveManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckUnhandledApprove",
			Handler:    _ApproveManagement_CheckUnhandledApprove_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "approve/approve.proto",
}
